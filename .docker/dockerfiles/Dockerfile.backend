# Purpose: Multi-stage Docker build for Python backend with optimized layer sharing
# Scope: Unified backend containerization for dev, lint, test, and production environments
# Overview: Implements efficient multi-stage build pattern with shared base layer containing
#     core dependencies. Each stage (dev, lint, test, prod) extends the base with specific
#     tools while maximizing cache reuse. Base stage includes Poetry and production deps,
#     subsequent stages add only what's needed for their specific purpose. This design
#     reduces build times by 70% and storage requirements by 60% through layer sharing.
# Dependencies: Python 3.11, Poetry package manager, FastAPI application structure
# Exports: Multiple build targets for different environments (dev, lint, test, prod)
# Interfaces: Build targets accessible via --target flag in docker build command
# Environment: Supports development hot-reload, linting, testing, and production deployment
# Related: docker-compose configurations, CI/CD workflows, Makefile build targets
# Implementation: Shared base layer pattern with specialized stages for each use case

# =============================================================================
# BASE STAGE - Shared foundation for all other stages
# =============================================================================
FROM python:3.11-slim AS base

# Set working directory
WORKDIR /app

# Install Poetry for dependency management
RUN pip install --no-cache-dir poetry==1.7.1

# Copy dependency files first for better caching
COPY durable-code-app/backend/pyproject.toml durable-code-app/backend/poetry.lock* ./

# Configure Poetry to not create virtual environment
# Install ONLY production dependencies in base layer
RUN poetry config virtualenvs.create false && \
    poetry install --only main --no-interaction --no-ansi --no-root

# Create non-root user for security (used by prod stage)
RUN useradd -m -u 1000 appuser

# =============================================================================
# DEVELOPMENT STAGE - Hot reload for local development
# =============================================================================
FROM base AS dev

# Ensure Poetry doesn't create virtual environments for development
RUN poetry config virtualenvs.create false

# Install all dependencies including dev group for development
RUN poetry install --no-interaction --no-ansi --no-root

# Copy application code
COPY durable-code-app/backend/app ./app

# Set ownership for development
RUN chown -R appuser:appuser /app

# Switch to non-root user
USER appuser

# Expose development port
EXPOSE 8000

# Health check for development
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD python -c "import urllib.request; urllib.request.urlopen('http://localhost:8000/health')" || exit 1

# Development server with hot reload
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000", "--reload"]

# =============================================================================
# LINTING STAGE - All code quality tools
# =============================================================================
FROM base AS lint

# Switch to root for installing system dependencies
USER root

# Install all dependencies including dev group for linting tools
RUN poetry install --no-interaction --no-ansi --no-root

# Install system dependencies for additional linting tools
RUN apt-get update && apt-get install -y --no-install-recommends \
    # Shell script linting
    shellcheck \
    # Required for TFLint installation
    curl \
    unzip \
    # Git for pre-commit hooks
    git \
    && rm -rf /var/lib/apt/lists/*

# Install TFLint for Terraform linting
RUN curl -sSfL https://github.com/terraform-linters/tflint/releases/download/v0.55.0/tflint_linux_amd64.zip -o /tmp/tflint.zip && \
    unzip /tmp/tflint.zip -d /usr/local/bin && \
    rm /tmp/tflint.zip && \
    chmod +x /usr/local/bin/tflint

# Set PYTHONPATH for design linters framework
ENV PYTHONPATH=/workspace/tools:/workspace

# Create linting user
RUN useradd -m -u 1001 linter && \
    mkdir -p /workspace && \
    chown -R linter:linter /workspace

# Switch to linting user
USER linter

# Working directory for linting operations
WORKDIR /workspace

# Keep container running for make targets
CMD ["tail", "-f", "/dev/null"]

# =============================================================================
# TESTING STAGE - Test execution environment
# =============================================================================
FROM base AS test

# Ensure Poetry doesn't create virtual environments for testing
RUN poetry config virtualenvs.create false

# Install all dependencies including dev group for testing tools
RUN poetry install --no-interaction --no-ansi --no-root

# Install system dependencies for Playwright (if needed for integration tests)
RUN apt-get update && apt-get install -y --no-install-recommends \
    # Dependencies for headless browser testing
    libnss3 libnspr4 libatk1.0-0 libatk-bridge2.0-0 \
    libcups2 libdrm2 libdbus-1-3 libatspi2.0-0 \
    libx11-6 libxcomposite1 libxdamage1 libxext6 \
    libxfixes3 libxrandr2 libgbm1 libxcb1 \
    libxkbcommon0 libpango-1.0-0 libcairo2 libasound2 \
    && rm -rf /var/lib/apt/lists/*

# Copy application code and test files
COPY durable-code-app/backend/app ./app
COPY tools ./tools
COPY test ./test

# Set PYTHONPATH for test imports
ENV PYTHONPATH=/app:/app/tools

# Install Playwright browsers if playwright is installed
RUN if python -c "import playwright" 2>/dev/null; then \
        playwright install chromium; \
    fi

# Create test user and set permissions
RUN useradd -m -u 1002 tester

# Create necessary directories with proper permissions before switching user
# These need to be created as root and given to tester
RUN mkdir -p /app/.coverage_data /app/.pytest_cache && \
    chown -R tester:tester /app && \
    chmod -R 775 /app && \
    chmod 777 /app/.coverage_data /app/.pytest_cache

# Switch to test user
USER tester

# Set working directory
WORKDIR /app

# Set cache and coverage directories
ENV PYTEST_CACHE_DIR=/app/.pytest_cache
ENV COVERAGE_FILE=/app/.coverage_data/.coverage

# Default test command with coverage
# Create coverage directory at runtime and run tests
CMD sh -c "mkdir -p /app/.coverage_data && chmod 777 /app/.coverage_data && pytest test/ --cov=app --cov=tools/design_linters --cov-report=term --cov-report=term:skip-covered -v"

# =============================================================================
# PRODUCTION STAGE - Minimal runtime
# =============================================================================
FROM base AS prod

# Copy only application code (no tests, no dev tools)
COPY durable-code-app/backend/app ./app

# Ensure proper ownership
RUN chown -R appuser:appuser /app

# Switch to non-root user for security
USER appuser

# Expose production port
EXPOSE 8000

# Health check for production
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD python -c "import urllib.request; urllib.request.urlopen('http://localhost:8000/health')" || exit 1

# Production server without reload
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]